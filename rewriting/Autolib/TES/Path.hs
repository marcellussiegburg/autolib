{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "TES/Path.hs.drift" #-}
-- -*- mode: haskell -*-

module TES.Path where

-- $Id$

import TES.Term
import TES.Data
import TES.Symbol

import Reader
import ToDoc

import Util.Sort

data Path = Path { descent :: [ ( Symbol, Int) ]
		 , variable :: Maybe Symbol
		 }
    deriving ( Eq, Ord )

{-! for Path derive : Reader, ToDoc !-}

instance Show Path where show = render . toDoc
instance Read Path where readsPrec = parsec_readsPrec

paths :: TES -> Term -> [ Path ]
paths tes ( Node f []   ) = return $
    if is_variable tes f 
    then Path { descent = [] , variable = Just f }
    else Path { descent = [(f,0)], variable = Nothing }
paths tes ( Node f args ) = do
    (k, a) <- zip [ 1 .. ] args 
    p <- paths tes a
    return $ p { descent = (f ,k) : descent p }

{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance Reader Path where
    readerPrec d =
	       readerParen (d > 9)
	       (do my_reserved "Path"
		   my_braces ((do my_reserved "descent"
				  my_equals
				  aa <- readerPrec 0
				  my_comma
				  my_reserved "variable"
				  my_equals
				  ab <- readerPrec 0
				  return (Path aa ab))))

instance ToDoc Path where
    toDocPrec d (Path aa ab) = docParen (d >= 10)
	      (text "Path" <+> dutch_record
	       [text "descent" <+> equals <+> toDocPrec 0 aa,
		text "variable" <+> equals <+> toDocPrec 0 ab])

--  Imported from other files :-
