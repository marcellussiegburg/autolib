-- -*- mode: haskell -*-

module NFTA.Type 

( module NFTA.Type
, module Sets
, module TES.Symbol
)

where

--  $Id$

import Sets
import Letters
import Util.Size
import TES.Symbol
import Reader
import ToDoc
import qualified Relation
import Hash

class ( Symbol c
      , Ord s , ToDoc s
      , ToDoc [s], Reader [s]
      , Reader s
      , Hash c, Hash s
      ) => NFTAC c s

instance ( Symbol c
      , Ord s , ToDoc s
      , ToDoc [s], Reader [s]
      , Reader s
      , Hash c, Hash s
      ) => NFTAC c s

data ( NFTAC c s ) => NFTA c s = 
     NFTA { states :: Set s
	  , finals :: Set s
	  -- | ( p, f, [q1, .. ] ) means transition p <- f [q1, .. ]
	  -- , trans  :: Set ( s, c, [s] )

	  , trans :: Relation.Type s (c,  [s]) 
	  , inv_trans :: Relation.Type ([s] , c) s

	  -- | ( p, q ) means transition  p <- q (in accepting bottom-up comp.)
	  -- this relation is always kept reflexive and transitive
	  , eps     :: Relation.Type s s 
	  -- | and this is always the inverse of above
	  , inv_eps :: Relation.Type s s
	  }
     deriving Eq

instance ( NFTAC c s ) => Hash ( NFTA c s ) where
    hash a = hash ( finals a, trans a , eps a )

lstates :: NFTAC c s => NFTA c s -> [s]
lstates = setToList . states

lfinals :: NFTAC c s => NFTA c s -> [s]
lfinals = setToList . finals

ltrans :: NFTAC c s => NFTA c s -> [(s, c, [s])]
ltrans  a = do ( p, (c, qs )) <- Relation.pairs ( trans a )
	       return ( p, c, qs )

leps :: NFTAC c s => NFTA c s -> [ (s, s) ]
leps = Relation.pairs . eps

instance  NFTAC c s => Letters (NFTA c s) c where
    letters a = mkSet $ do
        ( p, c, qs ) <- ltrans a
	return c

instance NFTAC c s  => Size ( NFTA c s ) where
    size = cardinality . states

{-! for NFTA derive: Reader, ToDoc !-}

instance NFTAC c s => Read (NFTA c s) where
    readsPrec = parsec_readsPrec

instance NFTAC c s => Show (NFTA c s) where
    show = render . toDoc
