-- -*- mode: haskell -*-

module NFTA.Type 

( module NFTA.Type
, module Sets
, module TES.Symbol
)

where

--  $Id$

import Sets
import Letters
import Util.Size
import TES.Symbol
import Reader
import ToDoc

class ( Symbol c
      , Ord s , ToDoc s
      , ToDoc [s], Reader [s]
      , Reader s
      ) => NFTAC c s

instance ( Symbol c
      , Ord s , ToDoc s
      , ToDoc [s], Reader [s]
      , Reader s
      ) => NFTAC c s

data ( NFTAC c s ) => NFTA c s = 
     NFTA { states :: Set s
	  , finals :: Set s
	  -- | ( p, f, [q1, .. ] ) means transition p <- f [q1, .. ]
	  , trans  :: Set ( s, c, [s] )
	  -- | ( p, q ) means transition  p <- q
	  , eps    :: Set ( s, s )
	  }

lstates :: NFTAC c s => NFTA c s -> [s]
lstates = setToList . states

lfinals :: NFTAC c s => NFTA c s -> [s]
lfinals = setToList . finals

ltrans :: NFTAC c s => NFTA c s -> [(s, c, [s])]
ltrans  = setToList . trans

leps :: NFTAC c s => NFTA c s -> [ (s, s) ]
leps = setToList . eps

instance  NFTAC c s => Letters (NFTA c s) c where
    letters a = mkSet $ do
        ( p, c, qs ) <- ltrans a
	return c

instance NFTAC c s  => Size ( NFTA c s ) where
    size = cardinality . states

{-! for NFTA derive: Reader, ToDoc !-}

instance NFTAC c s => Read (NFTA c s) where
    readsPrec = parsec_readsPrec

instance NFTAC c s => Show (NFTA c s) where
    show = render . toDoc
