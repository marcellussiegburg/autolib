{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "NFA/Data.hs.drift" #-}
-- -*- mode: haskell -*-

-- $Id$

module NFA.Data

( module NFA.Data
, module Informed
, module FiniteMap
, module Sets
)

where

import Sets
import Size
import Letters

import FiniteMap
import ReadFM

import Informed
import ToDoc
import Reader

import Monad (guard)

-- mal sehen
type NFA_Char s = NFA Char s

class ( Ord c, Ord s
      , ToDoc c, ToDoc s
      , Reader c, Reader s
                , Reader [s]
	        , ToDoc [s]
      ) => NFAC c s 
-- ohne methoden, nur constraints sammeln


instance ( Ord c, Ord s
      , ToDoc c, ToDoc s
      , Reader c, Reader s
                , Reader [s]
	        , ToDoc [s]
      ) => NFAC c s


{-
instance ( Ord c, ToDoc c, Reader c) => NFAC c Int
instance ( NFAC c s ) => NFAC c (Set s)
instance ( NFAC c s, NFAC c t ) => NFAC c (s, t)
instance ( NFAC c s, NFAC c t, NFAC c u ) => NFAC c (s, t, u)
instance ( NFAC c s, NFAC c t ) => NFAC c (Either s t)
-}


data NFAC c s => NFA c s = 
     NFA { nfa_info   :: Doc   -- wird nicht gelesen und auch nicht geprintet
	 , states :: Set s
	 , starts :: Set s
	 , finals :: Set s
	 , trans  :: FiniteMap (s, c) (Set s)
	 }

{-! for NFA derive : ToDoc, Reader !-}

instance NFAC c s
    => Show ( NFA c s ) where
        show = render . toDoc

instance NFAC c s
    => Read ( NFA c s ) where
        readsPrec = parsec_readsPrec

instance NFAC c s
    => Informed (NFA c s) where
    info = nfa_info
    informed i a = a { nfa_info = i }

instance NFAC c s
    => Size (NFA c s) where 
    size = cardinality . states




{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance (NFAC c s,ToDoc c,ToDoc s) => ToDoc (NFA c s) where
    toDocPrec d (NFA aa ab ac ad ae) = docParen (d >= 10)
	      (text "NFA" <+> dutch_record
	       [text "states" <+> equals <+> toDocPrec 0 ab,
		text "starts" <+> equals <+> toDocPrec 0 ac,
		text "finals" <+> equals <+> toDocPrec 0 ad,
		text "trans" <+> equals <+> toDocPrec 0 ae])

instance (NFAC c s,Reader c,Reader s) => Reader (NFA c s) where
    readerPrec d =
	       readerParen (d > 9)
	       (do my_reserved "NFA"
		   my_braces ((do aa <- parsed_info
				  my_reserved "states"
				  my_equals
				  ab <- readerPrec 0
				  my_comma
				  my_reserved "starts"
				  my_equals
				  ac <- readerPrec 0
				  my_comma
				  my_reserved "finals"
				  my_equals
				  ad <- readerPrec 0
				  my_comma
				  my_reserved "trans"
				  my_equals
				  ae <- readerPrec 0
				  return (NFA aa ab ac ad ae))))

--  Imported from other files :-
