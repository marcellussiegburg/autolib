-- -*- mode: haskell -*-

--   $Id$

module Autolib.NFA.Data

( module Autolib.NFA.Data
, module Autolib.Informed
, module Data.FiniteMap
, module Autolib.Sets
)

where

import Autolib.Sets
import Autolib.Size
import Autolib.Letters

import Data.FiniteMap
import Autolib.ReadFM

import Autolib.Informed
import Autolib.ToDoc
import Autolib.Reader
import Autolib.Hash

import Autolib.Symbol

import Control.Monad (guard)

-- mal sehen
type NFA_Char s = NFA Char s

class ( Ord c, Ord s
      , Hash c, Hash s
      , Symbol c
      , ToDoc c, ToDoc [c]
                , ToDoc s
      , Reader c, Reader s
                , Reader [s]
	        , ToDoc [s]
      ) => NFAC c s 
-- ohne methoden, nur constraints sammeln


instance ( Ord c, Ord s
	 , Symbol c
	 , Hash c, Hash s
      , ToDoc c, ToDoc [c]
      ,          ToDoc s
      , Reader c, Reader s
                , Reader [s]
	        , ToDoc [s]
      ) => NFAC c s


{-
instance ( Ord c, ToDoc c, Reader c) => NFAC c Int
instance ( NFAC c s ) => NFAC c (Set s)
instance ( NFAC c s, NFAC c t ) => NFAC c (s, t)
instance ( NFAC c s, NFAC c t, NFAC c u ) => NFAC c (s, t, u)
instance ( NFAC c s, NFAC c t ) => NFAC c (Either s t)
-}


data NFAC c s => NFA c s = 
     NFA { nfa_info   :: Doc   -- wird nicht gelesen und auch nicht geprintet
	 , states :: Set s
	 , starts :: Set s
	 , finals :: Set s
	 , trans  :: FiniteMap (s, c) (Set s)
	 }

{-! for NFA derive : ToDoc, Reader !-}

instance NFAC c s
    => Show ( NFA c s ) where
        show = render . toDoc

instance NFAC c s
    => Read ( NFA c s ) where
        readsPrec = parsec_readsPrec

instance NFAC c s
    => Informed (NFA c s) where
    info = nfa_info
    informed i a = a { nfa_info = i }

instance NFAC c s
    => Size (NFA c s) where 
    size = cardinality . states

instance NFAC c s 
    => Hash ( NFA c s ) where
    hash  = hash . essence

instance NFAC c s
    => Eq ( NFA c s ) where
    a == b  =  essence a == essence b

essence a = ( states a, starts a, finals a, trans a )

